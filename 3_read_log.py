import os
import pandas as pd
import numpy as np 
import matplotlib.pyplot as plt
import json
import sys

#* ------------------------------------------------------
#*       Read all  result log and fetch family mis-labelled data.
#*       Save those data  into log , csv, and figure in order to future analyzing .
#*        However, everytime using this program is necessary to revise "command" variable 
#*
#* -------------------------------------------------------

def get_all_log_list(path):
    path = path.replace(" ","")
    if not path.endswith('/'):
        path= path +'/'
    
    log_list=[ ]
    for dirpath,dirname,filename in os.walk(path):
        for f in filename:
            if f.endswith(".log"):
                file_path = dirpath+'/'+f
                log_list.append(file_path)
    return log_list

def down_level_for_path(path):
    if not path.endswith('/'):
        path = path+'/'
    last_folder = path.split('/')[-2]
    length = len(last_folder)+1

    return path[0:(-1* length)]
    
if __name__ == "__main__":
    
    
    file_folder = sys.argv[1] #!'/home//barry/project_result/resut_of_HPC/AMD40_de/2nd_ex/all_log/'
    
    if not file_folder.endswith('/'):
        file_folder = file_folder +'/'
    
    label_name = file_folder.split('/')[-2]
    print(label_name)

    save = down_level_for_path( file_folder) + 'summary'
    if not os.path.exists(save):
        os.mkdir(save)

    save = save+'/'+label_name
    
    if not os.path.exists(save):
        os.mkdir(save)
    
    if not save.endswith('/'):
        save =save + '/'
    
    
    log_list = get_all_log_list(file_folder)
    family_comparison_list_FN = [ ]
    family_comparison_list_FP = [ ]

    count = 0
    command = '\'C&C-SMS\'' 
    
    #C&C label-8
    #C&C-CE label-9
    #C&C-IN label-10
    #C&C-SMS  label-11
    
    #*   read all log file and using "grep" command to fnd mis-labelled prediction from RandomForest 
    #*    save false positive and false negative  into .log file for each label combination
    #*    also  the paths of above log files save to FP_list and FN_list for following process, respectively.
    for log in log_list:
        split_path = log.split('/')
        saving_loc_FN = save + 'mislabel_file_FN_'+split_path[-1].split('_')[1]+'_.log'
        saving_loc_FP = save + 'mislabel_file_FP_'+split_path[-1].split('_')[1]+'_.log'
        os.system( 'cat %s | grep -iP %s | grep -iP \'wrong one is 0\' | awk  \'{ print $2 } \' >  %s ' % (log, command,saving_loc_FN) )
        os.system( 'cat %s | grep -iP %s | grep -iP \'wrong one is 1\' | awk  \'{ print $2 } \' >  %s ' % (log, command,saving_loc_FP) ) 
        family_comparison_list_FN.append(saving_loc_FN)
        family_comparison_list_FP.append(saving_loc_FP)
        count = count +1
    
    print('Total : %s'%(count))
    
    text_data_FN = { }

    #* using FN log files to find what is the sample that is mis-labled by all models (the way to do stacking method )
    #*  save result in to csv and txt file
    #*  csv file include all mis-labelled samples
    #*  txt file include number of all mis-labelled samples
    
    for f_file in family_comparison_list_FN:
        f = open(f_file)
        
        FN=0
        for line in f:
            if line.endswith('\n'):
                line = line[:-1]
            if line not in text_data_FN:
                text_data_FN[line] = 1
            else:
                text_data_FN[line] = text_data_FN[line] + 1
            FN = FN+1
        f_file_name = f_file.split('/')[-1]
        f_file_label =f_file_name.split('_')[3]

        if f_file_label == label_name:
            f_file_FN = f_file[:-1*len(f_file_name)]+f_file_label+'_FN_.txt'
            FN_txt = open (f_file_FN,'w+')
            FN_txt.write('%d'%FN)
            FN_txt.close()

    ser_FN = pd.Series(text_data_FN)
    ser_FN = ser_FN.sort_values(ascending= False)
        
    print('---------------------------------------------\n\n')
    print(ser_FN)
    print(ser_FN[ser_FN>(len(family_comparison_list_FN)-1)])
    print('---------------------------------------------')

        
    if not save.endswith('/'):
        save = save + '/'

    ser_FN = ser_FN[ser_FN>(len(family_comparison_list_FN)-1)]
    
    saing = save+label_name+'_FN_.csv'
    ser_FN.to_csv(saing, header = False)
    
    new_save = down_level_for_path(save)
    saing = new_save+label_name+'_FN_.csv'
    ser_FN.to_csv(saing, header = False)
    f.close()


    #* using all FP log files to find what is the sample that is mis-labled by all models (the way to do stacking method )
    #*  save result in to csv and txt file
    #*  csv file include all mis-labelled samples
    #*  txt file include number of all mis-labelled samples 
    text_data_FP = { }
    for f_file in family_comparison_list_FP:
        f = open(f_file)
        
        FP = 0
        for line in f:
            if line.endswith('\n'):
                line = line[:-1]
            if line not in text_data_FP:
                text_data_FP[line] = 1
            else:
                text_data_FP[line] = text_data_FP[line] + 1
            FP = FP+1
        
        f_file_name = f_file.split('/')[-1]
        f_file_label =f_file_name.split('_')[3]
        if f_file_label == label_name:
            f_file_FP = f_file[:-1*len(f_file_name)]+f_file_label+'_FP_.txt'
            FP_txt = open (f_file_FP,'w+')
            FP_txt.write('%d'%FP)
            FP_txt.close()

    ser_FP = pd.Series(text_data_FP)
    ser_FP = ser_FP.sort_values(ascending= False)
    
    print('---------------------------------------------\n\n')
    print(ser_FP)
    print(ser_FP[ser_FP>(len(family_comparison_list_FP)-1)])
    print(len(family_comparison_list_FP))
    print('---------------------------------------------')
        
    if not save.endswith('/'):
        save = save + '/'
    
    ser_FP = ser_FP[ser_FP>(len(family_comparison_list_FP)-1)]
    saing = save+label_name+'_FP_.csv'
    ser_FP.to_csv(saing, header = False)

    new_save = down_level_for_path(save)
    saing = new_save+label_name+'_FP_.csv'
    ser_FP.to_csv(saing, header = False)
    f.close()



